{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Today I Learned","title":"Today I Learned"},{"location":"#today-i-learned","text":"","title":"Today I Learned"},{"location":"android/Fragment/","text":"Fragment Fragments when is it created and destroyed? setHasOptionMenu() Singleton Pattern Fragment Arguments Starting an activity from a fragment Fragment arguments For the More Curious: Why Use Fragment Arguments? Why not just set an instance variable on the CrimeFragment when it is created? Retaining fragments from desrtroying A Fragment represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments cannot live on their own--they must be hosted by an activity or another fragment. The fragment\u2019s view hierarchy becomes part of, or attaches to, the host\u2019s view hierarchy. onCreateView(inflater, container, savedInstanceState) Fragment Life Cycle ListFragment Displays a list of items that are managed by an adapter, similar to ListActivity. It provides several methods for managing a list view, such as the onListItemClick() callback to handle click events. PreferenceFragmentCompat Displays a hierarchy of Preference objects as a list. This is used to create a settings screen for your application. DialogFragment https://developer.android.com/reference/androidx/fragment/app/DialogFragment Displays a floating dialog. A DialogFragment is a special fragment subclass that is designeed for creating and hosting dialogs. Strictly speaking, you do not need to host your dialog within a fragment, but doing so allows the FragmentManager to manage the state of the dialog and automatically restore the dialog when a configuration change occurs. import androidx.fragment.app.DialogFragment; public class MyDialogFragment extends DialogFragment { override fun onCreateView() { } override fun onViewCreaed() { } override fun onCreateDialog() { } } // Show dialog FrgmentManager fm = getSupportFragmentManager() val myDialogFragment = MyDialogFragment.newInstance() myDialogFragment.show(fm, \"my_dialog_fragment\") LifeCycle # on start onAttach onCreate onCreateDialog onCreateView onActivityCreated onStart onResume # on destroying onPause onStop onDestroyView onDestroy onDetach Dialog Dialog is a small window that prompts user to make a decision or enter additional information. Dialog is the base class for dialogs, but you should avoid instantiating Dialog directly. Instead, user one of the following subclasses: - AlertDialog - DatePickerDialog - TimePickerDIalog These classes define style and structure for your dialog, but you should use a DialogFragment as a container for your dialog. The DialogFragment class provides all the controls you need to create the dialog and manage its appearance, instead of calling methods on the Dialog object. FragmentManager Every FragmentActivity and its subclasses. such as AppCompatActivity, have access to the FragmentManager through getSupportFragmentManager() Fragments can access host FragmentManager using getParentFragmentManager() Fragments arte capable of hosting one or moree child fragments. Inside a fragment, you can get a refference to the FragmntManager that manages the fragment's childreen through getChildFragmentManager() <image src=\"https://developer.android.com/images/fragment_lifecycle.png\" align=right> Represents a portion of user interface in an Activity. Fragment class looks a lot like an Activity. It contains callback methods simillar to an Activity. In fact, if you're converting an existing Android application to use fragments, you might simply move code from your activity's callback methods into the respective callback methods of your fragment. onCreate : The system calls this when creating the fragment. onCreateView : onPause : There are also a few subclasses that you might want to extend, instead of the base Fragment class: class MyFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { // Inflate the layout for this fragment return inflater.inflate(R.layout.my_fragment, container, false) } } FAQ setFragmentResult & setFragmentResultListener Reference https://developer.android.com/guide/fragments https://material.io/components/dialogs https://developer.android.com/guide/topics/ui/dialogs https://developer.android.com/guide/fragments/dialogs https://developer.android.com/reference/android/app/DialogFragment https://developer.android.com/reference/androidx/fragment/app/DialogFragment","title":"Fragment"},{"location":"android/Fragment/#fragment","text":"Fragments when is it created and destroyed? setHasOptionMenu() Singleton Pattern Fragment Arguments Starting an activity from a fragment Fragment arguments For the More Curious: Why Use Fragment Arguments? Why not just set an instance variable on the CrimeFragment when it is created? Retaining fragments from desrtroying A Fragment represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments cannot live on their own--they must be hosted by an activity or another fragment. The fragment\u2019s view hierarchy becomes part of, or attaches to, the host\u2019s view hierarchy. onCreateView(inflater, container, savedInstanceState) Fragment Life Cycle","title":"Fragment"},{"location":"android/Fragment/#listfragment","text":"Displays a list of items that are managed by an adapter, similar to ListActivity. It provides several methods for managing a list view, such as the onListItemClick() callback to handle click events.","title":"ListFragment"},{"location":"android/Fragment/#preferencefragmentcompat","text":"Displays a hierarchy of Preference objects as a list. This is used to create a settings screen for your application.","title":"PreferenceFragmentCompat"},{"location":"android/Fragment/#dialogfragment","text":"https://developer.android.com/reference/androidx/fragment/app/DialogFragment Displays a floating dialog. A DialogFragment is a special fragment subclass that is designeed for creating and hosting dialogs. Strictly speaking, you do not need to host your dialog within a fragment, but doing so allows the FragmentManager to manage the state of the dialog and automatically restore the dialog when a configuration change occurs. import androidx.fragment.app.DialogFragment; public class MyDialogFragment extends DialogFragment { override fun onCreateView() { } override fun onViewCreaed() { } override fun onCreateDialog() { } } // Show dialog FrgmentManager fm = getSupportFragmentManager() val myDialogFragment = MyDialogFragment.newInstance() myDialogFragment.show(fm, \"my_dialog_fragment\")","title":"DialogFragment"},{"location":"android/Fragment/#lifecycle","text":"# on start onAttach onCreate onCreateDialog onCreateView onActivityCreated onStart onResume # on destroying onPause onStop onDestroyView onDestroy onDetach","title":"LifeCycle"},{"location":"android/Fragment/#dialog","text":"Dialog is a small window that prompts user to make a decision or enter additional information. Dialog is the base class for dialogs, but you should avoid instantiating Dialog directly. Instead, user one of the following subclasses: - AlertDialog - DatePickerDialog - TimePickerDIalog These classes define style and structure for your dialog, but you should use a DialogFragment as a container for your dialog. The DialogFragment class provides all the controls you need to create the dialog and manage its appearance, instead of calling methods on the Dialog object.","title":"Dialog"},{"location":"android/Fragment/#fragmentmanager","text":"Every FragmentActivity and its subclasses. such as AppCompatActivity, have access to the FragmentManager through getSupportFragmentManager() Fragments can access host FragmentManager using getParentFragmentManager() Fragments arte capable of hosting one or moree child fragments. Inside a fragment, you can get a refference to the FragmntManager that manages the fragment's childreen through getChildFragmentManager() <image src=\"https://developer.android.com/images/fragment_lifecycle.png\" align=right> Represents a portion of user interface in an Activity. Fragment class looks a lot like an Activity. It contains callback methods simillar to an Activity. In fact, if you're converting an existing Android application to use fragments, you might simply move code from your activity's callback methods into the respective callback methods of your fragment. onCreate : The system calls this when creating the fragment. onCreateView : onPause : There are also a few subclasses that you might want to extend, instead of the base Fragment class: class MyFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { // Inflate the layout for this fragment return inflater.inflate(R.layout.my_fragment, container, false) } }","title":"FragmentManager"},{"location":"android/Fragment/#faq","text":"","title":"FAQ"},{"location":"android/Fragment/#setfragmentresult-setfragmentresultlistener","text":"","title":"setFragmentResult &amp; setFragmentResultListener"},{"location":"android/Fragment/#reference","text":"https://developer.android.com/guide/fragments https://material.io/components/dialogs https://developer.android.com/guide/topics/ui/dialogs https://developer.android.com/guide/fragments/dialogs https://developer.android.com/reference/android/app/DialogFragment https://developer.android.com/reference/androidx/fragment/app/DialogFragment","title":"Reference"},{"location":"android/Permissions/","text":"shouldShowRequestPermissionRationale() Returns true if the app has requested this permission previously and the user denied the request. If the user turned down the permission request in the past and chose the Don't ask again option, this method returns false . Calling shouldShowRequestPermissionRationale() first time before a permission denial will retturn false Reference https://stackoverflow.com/questions/32347532/android-m-permissions-confused-on-the-usage-of-shouldshowrequestpermissionrati SELECT * FROM `urs_prd`.`urs_raw_evt` WHERE (`activity_date`='20220223' AND `module_type`='video') OR (`activity_date`='20220223' AND `module_type`='sports_recent') OR (`activity_date`='20220223' AND `module_type`='search') OR (`activity_date`='20220223' AND `module_type`='p13n_stream') OR (`activity_date`='20220223' AND `module_type`='p13n_storypage') OR (`activity_date`='20220223' AND `module_type`='notification') OR (`activity_date`='20220223' AND `module_type`='newsroom') OR (`activity_date`='20220223' AND `module_type`='finance_recent_ticker') LIMIT 100 SELECT DISTINCT event_name FROM `urs_prd`.`annotated_mail_event_hourly_lite` WHERE (`generated_date`='2022022414') LIMIT 100","title":"Permissions"},{"location":"android/Permissions/#shouldshowrequestpermissionrationale","text":"Returns true if the app has requested this permission previously and the user denied the request. If the user turned down the permission request in the past and chose the Don't ask again option, this method returns false . Calling shouldShowRequestPermissionRationale() first time before a permission denial will retturn false","title":"shouldShowRequestPermissionRationale()"},{"location":"android/Permissions/#reference","text":"https://stackoverflow.com/questions/32347532/android-m-permissions-confused-on-the-usage-of-shouldshowrequestpermissionrati SELECT * FROM `urs_prd`.`urs_raw_evt` WHERE (`activity_date`='20220223' AND `module_type`='video') OR (`activity_date`='20220223' AND `module_type`='sports_recent') OR (`activity_date`='20220223' AND `module_type`='search') OR (`activity_date`='20220223' AND `module_type`='p13n_stream') OR (`activity_date`='20220223' AND `module_type`='p13n_storypage') OR (`activity_date`='20220223' AND `module_type`='notification') OR (`activity_date`='20220223' AND `module_type`='newsroom') OR (`activity_date`='20220223' AND `module_type`='finance_recent_ticker') LIMIT 100 SELECT DISTINCT event_name FROM `urs_prd`.`annotated_mail_event_hourly_lite` WHERE (`generated_date`='2022022414') LIMIT 100","title":"Reference"},{"location":"programming/DSL/","text":"","title":"DSL"},{"location":"tools/circleci/","text":"CircleCI FAQ Excluding a branch from CI Use workflow to ignore branches workflows: deploy: # workflow label jobs: - deploy: #job name filters: branches: ignore: - gh-pages # branch name to ignore You can restrict CI to a particular using only filter workflows: deploy: # workflow label jobs: - deploy: #job name filters: branches: only: gh-pages # branch name to ignore If it is not possible to create .circleci/config.yaml in this branch, you can enable Only build pull requests from project config in CircleCI. For your default branch and tags, it will always build all commits","title":"CircleCI"},{"location":"tools/circleci/#circleci","text":"","title":"CircleCI"},{"location":"tools/circleci/#faq","text":"","title":"FAQ"},{"location":"tools/circleci/#excluding-a-branch-from-ci","text":"Use workflow to ignore branches workflows: deploy: # workflow label jobs: - deploy: #job name filters: branches: ignore: - gh-pages # branch name to ignore You can restrict CI to a particular using only filter workflows: deploy: # workflow label jobs: - deploy: #job name filters: branches: only: gh-pages # branch name to ignore If it is not possible to create .circleci/config.yaml in this branch, you can enable Only build pull requests from project config in CircleCI. For your default branch and tags, it will always build all commits","title":"Excluding a branch from CI"},{"location":"tools/shell/","text":"$ which python3","title":"Shell"}]}